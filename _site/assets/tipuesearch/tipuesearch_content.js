var tipuesearch = {"pages": [{
    "title": "Equation of the circle passing through three points",
    "text": "It is well known that any three non-collinear points (A, B, C) determine a unique circle passing through them. Mathematically, we can find the circle center by computing the intersection point of the perpendicular bisectors of segments AB and AC. (Pairs AB and BC or pairs AC and BC would also work.) In code implementation, however, this method can be error-prone and require extra handling when the segment slope is nearly vertical. By searching the Internet carefully, I was finally able to find an algorithm that doesn’t deal with any slope computation, which is perfect for competitive programming. Please refer to this link for the original post. In case the website goes down in the future, I cited its content in below. The copyright all belongs to ambrsoft. The equation of an arbitrary circle can be described by the following equation: After substituting the three given points, and , which lie on the circle we get the set of equations that can be described by the determinant: The coefficients and can be found by solving the following determinants: The values of and will be after solving the determinants: Center point and the radius of the circle passing through and are: Here is the python code to find the circle center given three points (in format of pairs). def center(A, B, C): (x1, y1), (x2, y2), (x3, y3) = A, B, C A = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2 B = (x1 ** 2 + y1 ** 2) * (y3 - y2) + (x2 ** 2 + y2 ** 2) * (y1 - y3) + (x3 ** 2 + y3 ** 2) * (y2 - y1) C = (x1 ** 2 + y1 ** 2) * (x2 - x3) + (x2 ** 2 + y2 ** 2) * (x3 - x1) + (x3 ** 2 + y3 ** 2) * (x1 - x2) return (-B / A / 2, -C / A / 2)",
    "tags": "computational-geometry circle template algorithm math geometry",
    "url": "/blog/2020/03/17/circle-passing-3-pts/"
  },{
    "title": "LeetCode Weekly Contest 180",
    "text": "1380. Lucky Numbers in a Matrix 1381. Design a Stack With Increment Operation 1382. Balance a Binary Search Tree 1383. Maximum Performance of a Team 1380. Lucky Numbers in a Matrix [Problem] [Code] Since all elements are distinct in the matrix, we can pre-compute the min value per each row and the max value per each column. Then, we scan the matrix one more time and find all the candidates. Time: O(mn) Space: O(m + n) 1381. Design a Stack With Increment Operation [Problem] [Code] Maintain each prefix increment pointwisely and lazily. Then all operations can be implemented in O(1) time. 1382. Balance a Binary Search Tree [Problem] [Code] Do an in-order traversal to obtain all the elements in BST in sorted order. Then build the balanced tree using Divide-and-Conquer. Time: O(n) Space: O(n) 1383. Maximum Performance of a Team [Problem] [Code] Enumerate the engineer that has the minimum efficiency in the team. When each engineer is fixed, find those (at most) k engineers that have top speed. This algorithm can be implemented efficiently by (i) a pre-sorting on efficiency in decreasing order and (ii) using a heap or BST to maintain top-k speed. Time: O(n log n + n log k) = O(n log n) Space: O(k + sorting). When using (say) heap-sort, the complexity becomes O(k).",
    "tags": "leetcode coding",
    "url": "/blog/2020/03/17/leetcode-context-180/"
  },{
    "title": "Selective Aggregation (in Presto)",
    "text": "Solution - Selective Aggregation Fun Fact When counting in aggregation, you are probably familiar with both COUNT() and COUNT_IF(), where the latter counts after a selective filter. However, when it comes to other aggregation functions, there are simply no the corresponding _IF versions. One could argue that we could put the filter in WHERE, but this will not scale if we want to do multiple selective aggregations. Consider the following example. It would be really convenient to have these _IF aggregation variants, and otherwise one has to do each selective aggregation separately and finally join them together. SELECT key, SUM_IF(val1, condition1) AS sum1, SUM_IF(val1, condition2) AS sum2, ARRAY_AGG_IF(val2, condition3) AS vals, ... FROM table GROUP BY 1 Solution - Selective Aggregation We can now write the following query in Presto for selective aggregations. SELECT key, AGG1(x) FILTER (WHERE condition1), AGG2(y) FILTER (WHERE condition2), AGG3(z) FILTER (WHERE condition3), ... FROM table GROUP BY 1 Fun Fact I surfaced this cool feature from this request on Presto’s Github page. As stated by the last comment, Is this feature documented anywhere? I only found it because https://stackoverflow.com/questions/55504820/presto-filter-array-of-rows-inside-aggregation As of now, I still cannot find any related document on Presto’s main page, and this feature has just been silently supported since Dec 20, 2016…",
    "tags": "sql presto",
    "url": "/blog/2020/03/09/selective-aggregation/"
  },{
    "title": "LeetCode Weekly Contest 178",
    "text": "1365. How Many Numbers Are Smaller Than the Current Number 1366. Rank Teams by Votes 1367. Linked List in Binary Tree 1368. Minimum Cost to Make at Least One Valid Path in a Grid 1365. How Many Numbers Are Smaller Than the Current Number [Problem] [Code] Since each number is within the range [0, 100], we can use a counting sort based approach. Do a linear-time counting. Compute the prefix sum. Answer each query in O(1) time. Time: Space: 1366. Rank Teams by Votes [Problem] [Code] Assume there are m rounds of voting, we can solve this problem by a radix sort (from the m-th round to the first round). Time: , which can be further optimized to using counting sort. Space: 1367. Linked List in Binary Tree [Problem] [Code] It is hard to solve the problem in a top-down fashion since each tree node can have two choices. However, since each node has a unique parent, the upwards paths ending at any node are also unique (by its length). This suggests a DFS approach, where we just need to check whether the last m nodes on the stack match the given listed list at any time. Time: Space: m = linked list size, n = binary tree size, h = binary tree height 1368. Minimum Cost to Make at Least One Valid Path in a Grid [Problem] [Code] This is a single source shortest path problem. Build the graph For each grid cell, create four directed edges to its neighbors (if exist). The weight of the edge is 0 if the edge direction matches with the number in cell, otherwise the weight is 1. This means each cell will have exactly one outgoing edge with 0 weight, and two or three outgoing edges with weight equal to 1. Then, the length of the shortest path from top-left to bottom-right will be the answer. Time: , which can be further optimized to . This is because weights of edges in this graph are either 0 or 1, so we can compute the shortest path using BFS with a Deque. Formally, we insert to the head of the queue if the edge weight is 0 and insert to the tail of the queue if weight is 1. Space:",
    "tags": "leetcode coding",
    "url": "/blog/2020/03/08/leetcode-contest-178/"
  },{
    "title": "LeetCode Weekly Contest 177",
    "text": "1360. Number of Days Between Two Dates 1361. Validate Binary Tree Nodes 1362. Closest Divisors 1363. Largest Multiple of Three 1360. Number of Days Between Two Dates [Problem] [Code] Most programming languages should have date related packages. Worth getting familiar with them. 1361. Validate Binary Tree Nodes [Problem] [Code] There are multiple ways to validate a binary tree. Here is one way of doing that. There must be exactly $n - 1$ edges. There must be exactly one node with 0 in-degree, and that node is the root. Every other node must have in-degree equal to one. Time: Space: 1362. Closest Divisors [Problem] [Code] There can be at most pairs of divisors, so we can just enumerate all of them. Time: Space: , which can be further optimized to $O(1)$. 1363. Largest Multiple of Three [Problem] [Code] This is a math problem. We first have two facts that are easy to verify. Since , a number is a multiple of three if and only if the sum of digits is a multiple of three. When the set of digits is given, to gain the max value, we should concatenate them in decreasing order. And if the largest digit is zero (no matter how many zeros are there), the answer is also zero. If the set of digit is empty, we output empty string. Then, it is easier to solve this problem backwards, i.e., considering the digits we have to discard to make the final number as large as possible. Sum up all the digits and we have three cases based on its modulo (by 3). mod = 0. This is a happy case, and we should just use up all the digits. mod = 1. We should either discard a digit (that is 1 mod 3) or discard two digits (that are both 2 mod 3). Prefer to discard fewer digits. mod = 2. We should either discard a digit (that is 2 mod 2) or discard two digits (that are both 1 mod 3). Again, prefer to discard fewer digits. Time: $O(n \\log n)$, which can be optimized to $O(n)$ using counting sort. Space: $O(n)$",
    "tags": "leetcode coding",
    "url": "/blog/2020/02/23/leetcode-contest-177/"
  },{
    "title": "LeetCode Problem 152 - Maximum Product Subarray",
    "text": "LeetCode Problem 152 - Maximum Product Subarray First attempt Second Attempt Third Attempt LeetCode Problem 152 - Maximum Product Subarray [Problem][Github Code] First attempt This solution is complicated but marks how I started to tackle this problem. If the array contains only one element, then that’s the answer. If the array contains zeros, then answer is at least zero. In addition, any subarray that contains a zero will result in a zero product. Therefore, we can split the array by zero and obtain a list of subarrays that do not contain any zeros. Then, we can recursively solve these subproblems and take their max products and max with the zero product mentioned previously. Now, it suffices to assume that all elements in nums are integers with absolute value greater than 0. We then have two cases. If there are even number of negative integers, then it is clear that the total array product will be positive and will be the largest one. If there are odd number of negative integers and let’s assume that the first and last negative integers appear at index a and b, where 0 &lt;= a &lt;= b &lt; n, then the largest product must be either (nums[a + 1] * nums[a + 2] * ... * nums[n - 1]) or (nums[0] * nums[1] * ... * nums[b - 1]). For convenience, instead of doing exactly what the above algorithm suggests, it suffices to comptue all the prefix and suffix products and take the max. (This also covers 3.1.) Time: Space: if len(nums) == 1: return nums[0] if 0 in nums: ans = 0 cand = [] for i in nums: if i != 0: cand.append(i) else: if cand: ans = max(ans, self.maxProduct(cand)) cand = [] if cand: ans = max(ans, self.maxProduct(cand)) return ans else: ans = nums[0] prefix = 1 for i in nums: prefix *= i ans = max(ans, prefix) suffix = 1 for i in reversed(nums): suffix *= i ans = max(ans, suffix) return ans Second Attempt Initialize ans to be max(nums), which covers case 1 and the zero case of case 2. Do a global prefix and suffix product but restart the accumulating when encountering any zeros. This will cover the remaining part of case 2 and case 3. Time: Space: ans = max(nums) prefix = 1 for i in nums: if i: prefix *= i ans = max(ans, prefix) else: prefix = 1 suffix = 1 for i in reversed(nums): if i: suffix *= i ans = max(ans, suffix) else: suffix = 1 return ans Third Attempt Further simplify the code… But it will use extra space. Time: Space: A, B = nums, nums[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B)",
    "tags": "leetcode coding",
    "url": "/blog/2020/02/19/leetcode-problem-152/"
  },{
    "title": "LeetCode Weekly Contest 176",
    "text": "Count Negative Numbers in a Sorted Matrix Product of the Last K Numbers Maximum Number of Events That Can Be Attended Construct Target Array With Multiple Sums Count Negative Numbers in a Sorted Matrix [Problem] [Code] Essentially a Young Tableau problem. Start from the right top right cell. At each step, we can either remove a row or a column. Time: Extra space: Product of the Last K Numbers [Problem] [Code] My solution is a bit uncommon… Pay attention to the following statement At any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing. This means the following: The answer is 0 if there is at least a zero among the numbers. If there’s no zero, the # of distinct numbers that are greater than 1 cannot be more than , which is less than 32. Therefore, we can store the numbers in a compacted manner and then compute the product by brute-force. Time: for add, for product Space: Maximum Number of Events That Can Be Attended [Problem] [Code] Sweep time stamp $t$ for 0 to , for each , we would like to identify all the events whose interval contain , and attend the event with earliest ending time if any. Step 2 is the greedy step. For correctness: One needs to show that it cannot be worse to take an event at if there’s any candidate. One also needs to prove that it cannot be worse to take the event with earliest end time among all the feasible candidates. For implementation: Step 1 can be done efficiently via a global sorting on event’s start time. Step 2 can be maintained using a heap or balanced BST. Time: Space: Construct Target Array With Multiple Sums [Problem] [Code] Find the largest number in the array, then there’s a unique way to compute its value of the previous stage. Keep doing so until all numbers are equal to 1 –&gt; True any number becomes negative –&gt; False Use a SortedList / a Max-Heap for quick indexing. Time: , where $C$ is the largest element in the given list. Space:",
    "tags": "leetcode coding",
    "url": "/blog/2020/02/15/leetcode-176/"
  },{
    "title": "Disable hardware acceleration in Chrome",
    "text": "背景 解决方法 一个小发现 背景 自从更新了新的macOS到Catalina，我陆陆续续发现了一些问题。 微信和其他窗口之间切换一直特别卡，会有1-2秒左右的延迟。 Google Keep在chrome里切换tab也会特别卡，但是在其他浏览器（Firefox, Safari, …）中却没有这样的问题。 很长一段时间，我一直把锅丢给Chrome和mac的新操作系统… 解决方法 也许是歪打正着，我今天在网上闲逛有看看没有好的方案可以解决chrome狂吃cpu的问题。之后发现了一个帖子说禁用 Use hardware acceleration when available 这个选项会有一定的效果。 禁用了以后并没有发现明显的改善，但是微信以及Google Keep都可以瞬时切换了！非常神奇。。。 建议遇到过类似问题的小伙伴也试试看，希望可以解决你们的问题！ 一个小发现 看来mac版本的微信内部是用Chrome来渲染的。",
    "tags": "chrome wechat tip",
    "url": "/blog/2020/02/03/disable-hardware-acceleration-in-chrome/"
  },{
    "title": "Goldilocks and the Three Bears",
    "text": "Goldilocks and the Three Bears … At that moment, Goldilocks woke up. When she saw the three bears, she leaped out of the bed, ran down the stairs, through the door, into the woods, and all the way home! And she never visited the house of the three bears ever again.",
    "tags": "english",
    "url": "/blog/2020/01/10/goldilocks-and-the-three-bears/"
  },{
    "title": "Mad Man",
    "text": "Mad Man By Lionsgate And let’s also say that change is neither good nor bad - it simply is. It can be greeted with terror or joy; a tantrum that says “I want it the way it was,” or a dance that says “Look, something new.”",
    "tags": "typeracer english",
    "url": "/blog/2020/01/04/mad-man/"
  },{
    "title": "Min Cost Course Schedule",
    "text": "Problem Hardness Result &amp; Solution Problem LeetCode 630的加强版，我把它称为Min Cost Course Schedule。 给定$n$个course，每个course有三个属性 完成该课程需要的连续的时间$t_i$, 该课程的截止时间$d_i$, 修完该课程可以获得学分$c_i$. 这里不妨假设所有的数都是正整数，并且$t_i \\le n$。 现在要求一种最优的选课方式，使得总学分数最多。 Hardness Result &amp; Solution 首先，我们证明这个问题至少和01-背包一样难。 给定一个01-背包的问题：$n$个物体，每个物体的体积是$w_i$，价值是$v_i$。背包的总体积是$W$。 我们构造这样的一个min cost course schedule的问题实例。定义$n$个courses，每个course的完成时间记为$w_i$，获得学分数为$v_i$，所有的course的截止时间均为$W$。 很显然，后者问题的最优解直接imply前者01-背包的一个最优解。 接着我们给出一个基于DP的伪多项式解法。 我们先将所有的courses按照截止时间$d_i$从小到大排序，然后我们会有下面这个重要的（基于贪心的）结论。 Lemma 假设在某组最优解中，我们学习了课程$i_1, i_2, \\dots, i_m$，这里$i_1 &lt; i_2 &lt; \\dots &lt; i_m$，那么也一定存在一组最优解使得我们从左到右顺次学习这些课程。 证明： 假设结论不立，那么一定会存在$i_x$和$i_y$使得我们先上$i_x$，然后紧接着就上$i_y$，但是$x &gt; y$。 不妨假设$i_x$之前的课我们一共花了$T$的时间，于是我们一定有 (1) $T + t_{i_x} \\le d_{i_x}$, (2) $T + t_{i_x} + t_{i_y} \\le d_{i_y}$, (3) $d_{i_x} \\ge d_{i_y}$ （这是因为$x &gt; y$）. 现在我们颠倒一下$i_x$和$i_y$的学习顺序得到一组新的解（即，先学$i_y$，后学$i_x$），我们证明这组解依然是合法的，所以也是一组最优解（因为学习的课程总数并没有发生变化）。 (1) $i_y$之前和$i_x$之后的所有课程显然不会受到任何影响，所以它们一定是合法的。 (2) 考察$i_y$，我们总共花的时间是$T + t_{i_y} \\le T + t_{i_x} + t_{i_y} \\le d_{i_y}$，所以先上$i_y$没有问题。 (3) 然后考察$i_x$，我们总共花的时间是$T + t_{i_y} + t_{i_x} = T + t_{i_x} + t_{i_y} \\le d_{i_y} \\le d_{i_x}$，所以再上$i_x$也是合法的。$\\Box$ 有了上述Lemma，我们定义DP的状态$f[i][j]$表示：给定课程0到$i$，在累计上课时间不超过$j$的情况下，我们最多可以获得的学分数。状态转移如下： . 正确性读者可以自行理解，其中最后一个转移式子用到了上述的Lemma，它保证了我们可以把这个课放在最后学习。最终答案是$f[n - 1][\\min(\\sum{t_i}, d_{n-1})]$。 时间复杂度是$O(\\min(n^3, nd_{n-1}))$。 最后，上述的DP其实基本上和01-背包无异，也就是说这两个问题其实是等价的，同属于NP-Complete类。",
    "tags": "greedy dp reduction algorithm",
    "url": "/blog/2017/12/19/min-cost-course-schedule/"
  },{
    "title": "添加最少的边让有向图强连通",
    "text": "Problem 给定一个有向图$G$，问至少添加几条有向边可以使得$G$强连通。 Solution 先对$G$求强连通分支，缩点，然后得到一个DAG。如果最后的DAG只有一个节点，那么答案是0，否则答案是$\\max(in, out)$，这里$in$和$out$分别表示入度为0的点的总数和出度为0的点的总数。 Proof 首先$\\max(in, out)$肯定是一个下界，因为至少需要这么多边才能完全消除入度为0的所有的点或者出度为0的所有的点。 接着，我们用归纳法来构造一组合理的解。 给定任意一个图$G$，求它的强连通分量并且缩点得到一个DAG，令这个DAG为$D$。我们假设$|D| \\ge 2$，否则答案很显然是0。令$X$和$Y$分别表示$D$中入度和出度为0的点集。令$m = \\max(|X|, |Y|)$。我们通过对$m$进行归纳，claim是存在一种添加$m$条边的解法让$G$变得强连通。 Base: $m = 1$ 这个时候，很显然我们有$|X| = |Y| = 1$。假设$x$和$y$分别是$X$和$Y$的唯一元素，那么我们只需要添加边$(y, x)$即可。 当$m \\ge 2$的时候，我们考虑2个case。 Case 1: 存在$x \\in X$, $y \\in Y$使得$D$不存在从$x$到$y$的路径。这时我们添加一条边$(y, x)$。假设添加过边的新图为$G’$，求它的强连通分支并且缩点得到一个DAG $D’$。我们可以断定$D’ = D \\cup {(y, x)}$。原因很简单，如果$D$的点集在添加边$(y, x)$后发生了变化，唯一的可能是边$(y, x)$构成了环，这说明我们有$x$到$y$的路径，矛盾。 现在考虑新图$G’$和它的DAG $D’$，与$D$相比，$D’$少了一个入度为0的点，也少了一个出度为0的点，所以$m’ = m - 1$。根据归纳假设，我们需要再递归地添加$m’ - 1$条边，加上$(y, x)$本身，一共$m$条。 Case 2: 不存在上述的$x$和$y$，这意味着在DAG $D$中所有的$x \\in X$都有到所有的$y \\in Y$通路。这时我们可以随意取$D$中出度为0的点$y$和入度为0的点$x$，添加边$(y, x)$。如此重复$m$次即可。需要注意的是，如果某个时候不存在出度为0的点，那么就在$Y$中任取一点，如果不存在入度为0的点，就在$X$中任取一点。一个合理的推论是，当上述操作完成后，我们有以下两个性质： i. 对于$X$中的任何一点$x$，存在某个$y \\in Y$使得我们有边$(y, x)$。 ii. 对于$Y$中的任何一点$y$，存在某个$x \\in X$使得我们有变$(y, x)$。 接下来，我们需要证明，为什么这样随意的添加边之后$D$会变得强连通（因此$G$也就强连通了）。实际上，任取$D$中的两个点$a$和$b$，首先一定存在某个$y_1 \\in Y$（$y_1$可能是$a$本身），使得有$a$到$y_1$的路径。其次，根据性质(ii)，存在某个$x_1 \\in X$使得我们有边$(y_1, x_1)$。再看点$b$，容易知道一定存在某个$x_2 \\in X$使得$D$中存在$x_2$到$b$的路径($x_2$可能是$b$本身)。再根据性质(i)，存在某个$y_2 \\in Y$使得我们有边$(y_2, x_2)$。最后，根据一开始的假设，$X$中的每个点都有到$Y$中每个点的路径，即存在$x_1$到$y_2$的路径，于是我们找到了一条通路$a \\rightsquigarrow y_1 \\rightarrow x_1 \\rightsquigarrow y_2 \\rightarrow x_2 \\rightsquigarrow b$.",
    "tags": "graph strongly-connected-component algorithm",
    "url": "/blog/2017/12/06/add-min-edges-to-make-scc/"
  },{
    "title": "Hello World",
    "text": "Header 1 Header 2 Subheader 1 Header 1 Header 2 Subheader 1 This is a formula",
    "tags": "tag category",
    "url": "/blog/2017/08/29/hello-world/"
  },{
    "title": "Archives",
    "text": "Archives 2020 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm 2020-03-17 Tue. LeetCode Weekly Contest 180 coding leetcode 2020-03-09 Mon. Selective Aggregation (in Presto) sql sql&nbsp; presto 2020-03-08 Sun. LeetCode Weekly Contest 178 coding leetcode 2020-02-23 Sun. LeetCode Weekly Contest 177 coding leetcode 2020-02-19 Wed. LeetCode Problem 152 - Maximum Product Subarray coding leetcode 2020-02-15 Sat. LeetCode Weekly Contest 176 coding leetcode 2020-02-03 Mon. Disable hardware acceleration in Chrome tip chrome&nbsp; wechat 2020-01-10 Fri. Goldilocks and the Three Bears english english 2020-01-04 Sat. Mad Man english typeracer&nbsp; english 2017 2017-12-19 Tue. Min Cost Course Schedule algorithm greedy&nbsp; dp&nbsp; reduction 2017-12-06 Wed. 添加最少的边让有向图强连通 algorithm graph&nbsp; strongly-connected-component 2017-08-29 Tue. Hello World category tag Content 2020 (10) 2017 (3)",
    "tags": "",
    "url": "/archive/"
  },{
    "title": "Categories",
    "text": "Categories category 2017-08-29 Tue. Hello World category tag algorithm 2017-12-19 Tue. Min Cost Course Schedule algorithm greedy&nbsp; dp&nbsp; reduction 2017-12-06 Wed. 添加最少的边让有向图强连通 algorithm graph&nbsp; strongly-connected-component english 2020-01-10 Fri. Goldilocks and the Three Bears english english 2020-01-04 Sat. Mad Man english typeracer&nbsp; english tip 2020-02-03 Mon. Disable hardware acceleration in Chrome tip chrome&nbsp; wechat coding 2020-03-17 Tue. LeetCode Weekly Contest 180 coding leetcode 2020-03-08 Sun. LeetCode Weekly Contest 178 coding leetcode 2020-02-23 Sun. LeetCode Weekly Contest 177 coding leetcode 2020-02-19 Wed. LeetCode Problem 152 - Maximum Product Subarray coding leetcode 2020-02-15 Sat. LeetCode Weekly Contest 176 coding leetcode sql 2020-03-09 Mon. Selective Aggregation (in Presto) sql sql&nbsp; presto math 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm geometry 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm Content category (1) algorithm (2) english (2) tip (1) coding (5) sql (1) math (1) geometry (1)",
    "tags": "",
    "url": "/category/"
  },{
    "title": "Tags",
    "text": "Tags algorithm 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm chrome 2020-02-03 Mon. Disable hardware acceleration in Chrome tip chrome&nbsp; wechat circle 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm computational-geometry 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm dp 2017-12-19 Tue. Min Cost Course Schedule algorithm greedy&nbsp; dp&nbsp; reduction english 2020-01-10 Fri. Goldilocks and the Three Bears english english 2020-01-04 Sat. Mad Man english typeracer&nbsp; english graph 2017-12-06 Wed. 添加最少的边让有向图强连通 algorithm graph&nbsp; strongly-connected-component greedy 2017-12-19 Tue. Min Cost Course Schedule algorithm greedy&nbsp; dp&nbsp; reduction leetcode 2020-03-17 Tue. LeetCode Weekly Contest 180 coding leetcode 2020-03-08 Sun. LeetCode Weekly Contest 178 coding leetcode 2020-02-23 Sun. LeetCode Weekly Contest 177 coding leetcode 2020-02-19 Wed. LeetCode Problem 152 - Maximum Product Subarray coding leetcode 2020-02-15 Sat. LeetCode Weekly Contest 176 coding leetcode presto 2020-03-09 Mon. Selective Aggregation (in Presto) sql sql&nbsp; presto reduction 2017-12-19 Tue. Min Cost Course Schedule algorithm greedy&nbsp; dp&nbsp; reduction sql 2020-03-09 Mon. Selective Aggregation (in Presto) sql sql&nbsp; presto strongly-connected-component 2017-12-06 Wed. 添加最少的边让有向图强连通 algorithm graph&nbsp; strongly-connected-component tag 2017-08-29 Tue. Hello World category tag template 2020-03-17 Tue. Equation of the circle passing through three points math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm typeracer 2020-01-04 Sat. Mad Man english typeracer&nbsp; english wechat 2020-02-03 Mon. Disable hardware acceleration in Chrome tip chrome&nbsp; wechat Content algorithm (1) chrome (1) circle (1) computational-geometry (1) dp (1) english (2) graph (1) greedy (1) leetcode (5) presto (1) reduction (1) sql (1) strongly-connected-component (1) tag (1) template (1) typeracer (1) wechat (1)",
    "tags": "",
    "url": "/tag/"
  },{
    "title": "About",
    "text": "About Me About Me TBD Please enable JavaScript to view the comments powered by Disqus.",
    "tags": "",
    "url": "/about/"
  },{
    "title": "404: Page not found",
    "text": ":-( 404: Page not found!! Sorry, that URL is pointing to something that doesn't exist! You can go to my Home page or my Blog.",
    "tags": "",
    "url": "/404/"
  },{
    "title": "",
    "text": "Welcome to lydxlx's Blog! Equation of the circle passing through three points 2020-03-17 lydxlx math&nbsp; geometry computational-geometry&nbsp; circle&nbsp; template&nbsp; algorithm It is well known that any three non-collinear points (A, B, C) determine a unique circle passing through them. Mathematically, we can find the circle center by computing the intersection point of the perpendicular bisectors of segments AB and AC. (Pairs AB and BC or pairs AC and BC would also work.) In code implementation, however, this method can be error-prone and require extra handling when the segment slope is nearly vertical. By searching the Internet carefully, I was finally able to find an algorithm that doesn’t deal with any slope computation, which is perfect for competitive programming. Please refer to this link for the original post. In case the website goes down in the future, I cited its content in below. The copyright all belongs to ambrsoft. The equation of an arbitrary circle can be described by the following equation: After substituting the three given points, and , which lie on the circle we get the set of equations that can be described by the determinant: The coefficients and can be found by solving the following determinants: The values of and will be after solving the determinants: Center point and the radius of the circle passing through and are: Here is the python code to find the circle center given three points (in format of pairs). def center(A, B, C): (x1, y1), (x2, y2), (x3, y3) = A, B, C A = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2 B = (x1 ** 2 + y1 ** 2) * (y3 - y2) + (x2 ** 2 + y2 ** 2) * (y1 - y3) + (x3 ** 2 + y3 ** 2) * (y2 - y1) C = (x1 ** 2 + y1 ** 2) * (x2 - x3) + (x2 ** 2 + y2 ** 2) * (x3 - x1) + (x3 ** 2 + y3 ** 2) * (x1 - x2) return (-B / A / 2, -C / A / 2) Read All LeetCode Weekly Contest 180 2020-03-17 lydxlx coding leetcode 1380. Lucky Numbers in a Matrix 1381. Design a Stack With Increment Operation 1382. Balance a Binary Search Tree 1383. Maximum Performance of a Team 1380. Lucky Numbers in a Matrix [Problem] [Code] Since all elements are distinct in the matrix, we can pre-compute the min value per each row and the max value per each column. Then, we scan the matrix one more time and find all the candidates. Time: O(mn) Space: O(m + n) 1381. Design a Stack With Increment Operation [Problem] [Code] Maintain each prefix increment pointwisely and lazily. Then all operations can be implemented in O(1) time. 1382. Balance a Binary Search Tree [Problem] [Code] Do an in-order traversal to obtain all the elements in BST in sorted order. Then build the balanced tree using Divide-and-Conquer. Time: O(n) Space: O(n) 1383. Maximum Performance of a Team [Problem] [Code] Enumerate the engineer that has the minimum efficiency in the team. When each engineer is fixed, find those (at most) k engineers that have top speed. This algorithm can be implemented efficiently by (i) a pre-sorting on efficiency in decreasing order and (ii) using a heap or BST to maintain top-k speed. Time: O(n log n + n log k) = O(n log n) Space: O(k + sorting). When using (say) heap-sort, the complexity becomes O(k). Read All Selective Aggregation (in Presto) 2020-03-09 lydxlx sql sql&nbsp; presto Solution - Selective Aggregation Fun Fact When counting in aggregation, you are probably familiar with both COUNT() and COUNT_IF(), where the latter counts after a selective filter. However, when it comes to other aggregation functions, there are simply no the corresponding _IF versions. One could argue that we could put the filter in WHERE, but this will not scale if we want to do multiple selective aggregations. Consider the following example. It would be really convenient to have these _IF aggregation variants, and otherwise one has to do each selective aggregation separately and finally join them together. SELECT key, SUM_IF(val1, condition1) AS sum1, SUM_IF(val1, condition2) AS sum2, ARRAY_AGG_IF(val2, condition3) AS vals, ... FROM table GROUP BY 1 Solution - Selective Aggregation We can now write the following query in Presto for selective aggregations. SELECT key, AGG1(x) FILTER (WHERE condition1), AGG2(y) FILTER (WHERE condition2), AGG3(z) FILTER (WHERE condition3), ... FROM table GROUP BY 1 Fun Fact I surfaced this cool feature from this request on Presto’s Github page. As stated by the last comment, Is this feature documented anywhere? I only found it because https://stackoverflow.com/questions/55504820/presto-filter-array-of-rows-inside-aggregation As of now, I still cannot find any related document on Presto’s main page, and this feature has just been silently supported since Dec 20, 2016… Read All LeetCode Weekly Contest 178 2020-03-08 lydxlx coding leetcode 1365. How Many Numbers Are Smaller Than the Current Number 1366. Rank Teams by Votes 1367. Linked List in Binary Tree 1368. Minimum Cost to Make at Least One Valid Path in a Grid 1365. How Many Numbers Are Smaller Than the Current Number [Problem] [Code] Since each number is within the range [0, 100], we can use a counting sort based approach. Do a linear-time counting. Compute the prefix sum. Answer each query in O(1) time. Time: Space: 1366. Rank Teams by Votes [Problem] [Code] Assume there are m rounds of voting, we can solve this problem by a radix sort (from the m-th round to the first round). Time: , which can be further optimized to using counting sort. Space: 1367. Linked List in Binary Tree [Problem] [Code] It is hard to solve the problem in a top-down fashion since each tree node can have two choices. However, since each node has a unique parent, the upwards paths ending at any node are also unique (by its length). This suggests a DFS approach, where we just need to check whether the last m nodes on the stack match the given listed list at any time. Time: Space: m = linked list size, n = binary tree size, h = binary tree height 1368. Minimum Cost to Make at Least One Valid Path in a Grid [Problem] [Code] This is a single source shortest path problem. Build the graph For each grid cell, create four directed edges to its neighbors (if exist). The weight of the edge is 0 if the edge direction matches with the number in cell, otherwise the weight is 1. This means each cell will have exactly one outgoing edge with 0 weight, and two or three outgoing edges with weight equal to 1. Then, the length of the shortest path from top-left to bottom-right will be the answer. Time: , which can be further optimized to . This is because weights of edges in this graph are either 0 or 1, so we can compute the shortest path using BFS with a Deque. Formally, we insert to the head of the queue if the edge weight is 0 and insert to the tail of the queue if weight is 1. Space: Read All LeetCode Weekly Contest 177 2020-02-23 lydxlx coding leetcode 1360. Number of Days Between Two Dates 1361. Validate Binary Tree Nodes 1362. Closest Divisors 1363. Largest Multiple of Three 1360. Number of Days Between Two Dates [Problem] [Code] Most programming languages should have date related packages. Worth getting familiar with them. 1361. Validate Binary Tree Nodes [Problem] [Code] There are multiple ways to validate a binary tree. Here is one way of doing that. There must be exactly $n - 1$ edges. There must be exactly one node with 0 in-degree, and that node is the root. Every other node must have in-degree equal to one. Time: Space: 1362. Closest Divisors [Problem] [Code] There can be at most pairs of divisors, so we can just enumerate all of them. Time: Space: , which can be further optimized to $O(1)$. 1363. Largest Multiple of Three [Problem] [Code] This is a math problem. We first have two facts that are easy to verify. Since , a number is a multiple of three if and only if the sum of digits is a multiple of three. When the set of digits is given, to gain the max value, we should concatenate them in decreasing order. And if the largest digit is zero (no matter how many zeros are there), the answer is also zero. If the set of digit is empty, we output empty string. Then, it is easier to solve this problem backwards, i.e., considering the digits we have to discard to make the final number as large as possible. Sum up all the digits and we have three cases based on its modulo (by 3). mod = 0. This is a happy case, and we should just use up all the digits. mod = 1. We should either discard a digit (that is 1 mod 3) or discard two digits (that are both 2 mod 3). Prefer to discard fewer digits. mod = 2. We should either discard a digit (that is 2 mod 2) or discard two digits (that are both 1 mod 3). Again, prefer to discard fewer digits. Time: $O(n \\log n)$, which can be optimized to $O(n)$ using counting sort. Space: $O(n)$ Read All LeetCode Problem 152 - Maximum Product Subarray 2020-02-19 lydxlx coding leetcode LeetCode Problem 152 - Maximum Product Subarray First attempt Second Attempt Third Attempt LeetCode Problem 152 - Maximum Product Subarray [Problem][Github Code] First attempt This solution is complicated but marks how I started to tackle this problem. If the array contains only one element, then that’s the answer. If the array contains zeros, then answer is at least zero. In addition, any subarray that contains a zero will result in a zero product. Therefore, we can split the array by zero and obtain a list of subarrays that do not contain any zeros. Then, we can recursively solve these subproblems and take their max products and max with the zero product mentioned previously. Now, it suffices to assume that all elements in nums are integers with absolute value greater than 0. We then have two cases. If there are even number of negative integers, then it is clear that the total array product will be positive and will be the largest one. If there are odd number of negative integers and let’s assume that the first and last negative integers appear at index a and b, where 0 &lt;= a &lt;= b &lt; n, then the largest product must be either (nums[a + 1] * nums[a + 2] * ... * nums[n - 1]) or (nums[0] * nums[1] * ... * nums[b - 1]). For convenience, instead of doing exactly what the above algorithm suggests, it suffices to comptue all the prefix and suffix products and take the max. (This also covers 3.1.) Time: Space: if len(nums) == 1: return nums[0] if 0 in nums: ans = 0 cand = [] for i in nums: if i != 0: cand.append(i) else: if cand: ans = max(ans, self.maxProduct(cand)) cand = [] if cand: ans = max(ans, self.maxProduct(cand)) return ans else: ans = nums[0] prefix = 1 for i in nums: prefix *= i ans = max(ans, prefix) suffix = 1 for i in reversed(nums): suffix *= i ans = max(ans, suffix) return ans Second Attempt Initialize ans to be max(nums), which covers case 1 and the zero case of case 2. Do a global prefix and suffix product but restart the accumulating when encountering any zeros. This will cover the remaining part of case 2 and case 3. Time: Space: ans = max(nums) prefix = 1 for i in nums: if i: prefix *= i ans = max(ans, prefix) else: prefix = 1 suffix = 1 for i in reversed(nums): if i: suffix *= i ans = max(ans, suffix) else: suffix = 1 return ans Third Attempt Further simplify the code… But it will use extra space. Time: Space: A, B = nums, nums[::-1] for i in range(1, len(A)): A[i] *= A[i - 1] or 1 B[i] *= B[i - 1] or 1 return max(A + B) Read All 1/3 Recent Posts Equation of the circle passing through three points LeetCode Weekly Contest 180 Selective Aggregation (in Presto) LeetCode Weekly Contest 178 LeetCode Weekly Contest 177 LeetCode Problem 152 - Maximum Product Subarray LeetCode Weekly Contest 176 Disable hardware acceleration in Chrome Goldilocks and the Three Bears Mad Man Categories category 1 algorithm 2 english 2 tip 1 coding 5 sql 1 math 1 geometry 1 Tags tag graph strongly-connected-component greedy dp reduction typeracer english chrome wechat leetcode sql presto computational-geometry circle template algorithm",
    "tags": "",
    "url": "/"
  },{
    "title": "",
    "text": "Welcome to lydxlx's Blog! {% for post in paginator.posts %} {{ post.title }} {{ post.date | date: \"%F\" }} {% if post.author %}{{ post.author }} {% endif %} {% if page.meta %}{{ page.meta }} {% endif %} {% include category.html %} {% include tag.html %} {{post.excerpt}} Read All {% endfor %} {% if paginator.previous_page %} {% else %} {% endif %} {{ paginator.page }}/{{ paginator.total_pages }} {% if paginator.next_page %} {% else %} {% endif %} Recent Posts {% for post in site.posts offset: 0 limit: 10 %} {{ post.title }} {% endfor %} Categories {% for category in site.categories %} {{ category | first }} {{ category | last | size }} {% endfor %} Tags {% assign first = site.tags.first %} {% assign max = first[1].size %} {% assign min = max %} {% for tag in site.tags offset:1 %} {% if tag[1].size > max %} {% assign max = tag[1].size %} {% elsif tag[1].size {{ tag[0] }} {% endfor %}",
    "tags": "",
    "url": "/page2/"
  },{
    "title": "",
    "text": "Welcome to lydxlx's Blog! {% for post in paginator.posts %} {{ post.title }} {{ post.date | date: \"%F\" }} {% if post.author %}{{ post.author }} {% endif %} {% if page.meta %}{{ page.meta }} {% endif %} {% include category.html %} {% include tag.html %} {{post.excerpt}} Read All {% endfor %} {% if paginator.previous_page %} {% else %} {% endif %} {{ paginator.page }}/{{ paginator.total_pages }} {% if paginator.next_page %} {% else %} {% endif %} Recent Posts {% for post in site.posts offset: 0 limit: 10 %} {{ post.title }} {% endfor %} Categories {% for category in site.categories %} {{ category | first }} {{ category | last | size }} {% endfor %} Tags {% assign first = site.tags.first %} {% assign max = first[1].size %} {% assign min = max %} {% for tag in site.tags offset:1 %} {% if tag[1].size > max %} {% assign max = tag[1].size %} {% elsif tag[1].size {{ tag[0] }} {% endfor %}",
    "tags": "",
    "url": "/page3/"
  }]};
